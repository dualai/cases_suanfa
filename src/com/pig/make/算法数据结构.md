O(1) 常数时间内完成
O(n) 复杂度
实际时间： T = c1 * n + c2;

均摊时间复杂度：如果一个O(n)的操作并不是每次都会触发的话，那就用均摊时间复杂度来计算；

复杂度震荡：同时进行每次都会进行O(n)操作的组合操作，比如不断的进行resize, addLast和removeLast，会不断的触发扩容和缩容，
解决方案：lazy，找准lazy时间点
    当size--的时候，直到size = capacity / 4的时候，才将capacity减半


************
栈：

Undo操作：

程序调用的系统栈： 自己瞎想的，方法嵌套调用的时候，把中断号压栈，等最后一个函数执行完，再从栈中一个个取出中断点；从上一个中断点接着往下执行；

匹配括号


**********
/**
 * 队列：FIFO
 *
 * 数组队列：出队的时候，移动整个数组，时间复杂度O(n)，
 *
 * 循环队列：纪录队首的位置，出队的时候，时间复杂度O(1)，front ，tail，front == tail，队列为空；
 (tail+1) % capacity == front, 队列满了,故意腾出一个空位； 其中，front指在不为空的元素上，
            但是tail指在第一个为空的位置上；相当于[Front,tail) 这种；
 *          入队，维护tail；出队，维护front
 */
 
 %的意义，如果是个环状，取余，
 
 所以以后写播放列表，播放完成从头开始，那就index = (index+1) % data.length;
 
 ***********
 扩容是在添加元素之前就扩容；缩容是在移除数据，size--以后；
 
System.nanoTime() 纳秒；
纳秒-秒  九个0
纳秒 / 1000 000 000 .0f;

*******************
线性数据结构：

动态数组、栈、队列： 底层依托静态数组，靠resize实现容量增缩问题；

链表：






