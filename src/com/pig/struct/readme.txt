

2019年9月8日22:38:53
6、删除任意节点；
8、求一个数（不一定存在该节点）的floor和ceil


successor、predecessor：前驱、后继

rank： 给出一个元素，求它的排名
select：排名第10名的元素，取出它的元素
维护每个节点的size，来实现rank和select

维护深度值 depth；

支持重复元素的二分搜索树；  左子树<= 父节点；   右子树 > 父节点；
或者说，记录一个count变量给每个节点；

====================================================================

集合和映射，主要是二分搜索树实现的数据结构；

集合，二分搜索树，
treeset 红黑树，自平衡的二叉树，log2n 时间复杂度

映射，Map
本质和集合并没有太大差别，只不过每个节点存储两个数据，K，V

基于集合来实现映射；或者基于映射来实现集合； 比如HashMap和HashSet

一般是基于映射的底层来实现集合；比如将映射的value设为空，只考虑key，那就变成集合了；

=========================
树的拓展：堆、线段树、字典树(Trie)、并查集
=========================
堆和优先队列：

堆来实现优先队列

堆本身也是一棵树：
堆也有很多种，比较主流的叫做 二叉堆，满足一些特殊性质的二叉树；

二叉堆是一棵完全二叉树

完全二叉树在数组中的索引，求第一个非叶子节点在数组中的索引，利用最后一个元素的索引来求；

二叉堆，父节点>=其子节点 ，这叫做最大堆；
注意
1、最大堆只是最上面的那个数是最大的，但是并不是层级越上面的数字越大
2、

最小堆：。。。。

优先队列，堆的应用

java 自带的优先队列，可以接一个Comparator，来自定义元素的比较方式，覆盖自己的比较方式，比如覆盖String自己的比较方式；

Comparable 和 Comparator
其中 Comparator 往往可以直接用匿名内部类直接初始化；
=========================================================================
线段树（区间树）：

线段树                  数组
创建O(4n)               O(n)
查询O(logN)             O(n)
更新O(logN)             o(n)

非常重要：
    线段树的应用场景：

    用于统计一个区间，并且该区间中的元素需要经常进行更新，可以应用线段树；

    但是一定要注意，线段树这种数据结构不考虑改区间本身的大小发生变化； 区间本身大小是不变的，举个例子，一个数组长度是不变的，
    虽然里头每个元素可能经常变化；

    如果区间内的数据是静态的，那么可以用另外一种经典的方式进行查询,预处理后，查询的时间复杂度为O(1)，看题目；但是更新操作还是需要应用线段树，即使是静态的，更新操作的
    时间复杂度在数组中是O(n)


segment tree

区间染色：

基于区间的统计查询：  统计查询，假设要非常频繁的调用查询或者修改，如果每次都用数组，那么效率： 次数*log(N)
查找一个区间[i,j]的最大值，最小值，或者区间数字和；

也就是区间的
更新:更新区间中一个元素或者一个区间的值

查询：查询或者更新一个区间[i,j]的最大值，最小值，或者区间数字和；
数组：O(n）
线段树：O(logN）

数组实现：都是O(n)

使用线段树：都是O(logN)

做完创建、查询、修改以后，再来看时间和空间的复杂度，和数组对比的优势；

https://cloud.tencent.com/developer/article/1149069
https://www.cnblogs.com/iris001999/articles/9058603.html
https://www.jianshu.com/p/5769dcb06221

线段树不是完全二叉树

线段树是平衡二叉树：叶子节点高度不会相差1；

完全二叉树一定是平衡二叉树；

满二叉树：h-1层，有2^(h-1) 个元素   0~h-1层，一共有2^h - 1个节点，
         下一层是上一层的两倍节点数量； 最后一层的节点数量大概是总数的1/2，也就是等于前面所有层的和;

第n层(从0层算起)的个数是2^n ，前0~n-1层的总数是2^n - 1 一共的数量是 2^(n+1) - 1个；

创建线段树，如果有n个元素，那么数组需要开辟4n的空间；

int mid = (left+right) / 2;  可以计算出left和right的中间数； 但是有可能left+right会出现整型溢出，
所以，写成left+ (right - left) / 2比较好，这样也是中间数;

===========接口================
好好理解这个概念： 创建一个接口，由外面实现这个接口，接口中可以定义规则等；由内部调用这个规则；

观察者模式：  被观察者将观察者注册到自身中，观察者实现相关接口，需要的时候，触发观察者的方法；

-----------------------------------
概念补充：
满二叉树
完全二叉树
堆和树的区别（不是指的二叉树）

d叉堆d-ary heap,有d个分支的； O(LogdN), 到底d是多少，效率最高，需要实际上算一算；

索引堆（算法与数据结构）

二项堆

斐波那契堆

广义队列：
普通队列、优先队列、
栈，也可以理解成是一个队列；

----------------------------------练习题目-------------------------------------
递归!!!!
链表和二叉树
多练习链表和二叉树
二叉搜索树题目，再看看那一章的最后一节布置的一些拓展题目；
二叉搜索树：删除任意节点；
二叉搜索树：求一个数（不一定存在该节点）的floor和ceil

排序：
冒泡排序：两两对比，一轮一轮浮上去，选择排序

寻找树的最短公节点

集合和映射：
LeetCode：摩斯密码题目等，具体看那一节最后布置了哪些题目；
leetcode：求一个数组的交集等，具体看，集合，treeset

优先队列，堆：

N个元素选出前M大的

排序： NLogN

使用优先队列：
NLogM

频率前K高的元素；

用java标准库PriorityQueue解决以上这个问题


-----------------
求区间元素和，总是经常会调用sum函数；并且数组静态不变；
方法1：线段树
方法2：预处理

线段树更新操作：
















